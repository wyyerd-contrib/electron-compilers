'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;
let istanbul = null;
let sorcery = null;

const builtinKeys = ['hotModuleReload', 'coverage', 'babel'];

class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(sourceCode, filePath));
    }

    let output = ts.transpileModule(sourceCode, transpileOptions);
    let sourceMaps = output.sourceMapText ? output.sourceMapText : null;
    if (options.builtinOpts.coverage) {
      sourceMaps = null;
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      output.outputText = new istanbul.Instrumenter().instrumentSync(output.outputText, filePath);
    }

    d(JSON.stringify(output.diagnostics));

    const babelOpts = this.parsedConfig.builtinOpts.babel;
    if (babelOpts) {
      if (!this.babel) {
        const BabelCompiler = require("./babel").default;
        this.babel = new BabelCompiler();
        this.babel.compilerOptions = babelOpts;
      }

      sorcery = sorcery || require('sorcery');

      let tsOutputPath = filePath.replace(/.tsx?$/i, ".js");
      let babelOutputPath = filePath.replace(/.tsx?$/i, ".babel.js");

      output.outputText = output.outputText.replace(/\/\/# sourceMap.*/g, "");

      let babelOutput = this.babel.compileSync(output.outputText, tsOutputPath);
      let chain = sorcery.loadSync(babelOutputPath, {
        content: {
          [filePath]: sourceCode,
          [tsOutputPath]: output.outputText,
          [babelOutputPath]: babelOutput.code
        },
        sourcemaps: {
          [tsOutputPath]: JSON.parse(sourceMaps),
          [babelOutputPath]: JSON.parse(babelOutput.sourceMaps)
        }
      });
      let finalSourceMaps = chain.apply();
      let outputCode = babelOutput.code + "\n//# sourceMappingURL=" + finalSourceMaps.toUrl();

      // the only way to make sourceMaps usable seems to be to have
      // them inlined right now, see https://github.com/electron/electron-compile/issues/172#issuecomment-277146112
      return {
        code: outputCode,
        mimeType: babelOutput.mimeType
      };
    }

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => {
      let id = `${x}` == 'default' ? '(typeof _default !== \'undefined\' ? _default : exports.default)' : `${x}`;
      let name = `"${x}"`;
      return `__REACT_HOT_LOADER__.register(${id}, ${name}, __FILENAME__);\n`;
    });

    let tmpl = `
${sourceCode}

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${(0, _jsStringEscape2.default)(fileName)}";
  ${registrations}
}`;

    return tmpl;
  }

  getExportsForFile(sourceCode, fileName) {
    let sourceFile = ts.createSourceFile(fileName, sourceCode, ts.ScriptTarget.ES6);
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(node.name.text);
      }
    };

    ts.forEachChild(sourceFile, visit);

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImlzdGFuYnVsIiwic29yY2VyeSIsImJ1aWx0aW5LZXlzIiwiVHlwZVNjcmlwdENvbXBpbGVyIiwiY29uc3RydWN0b3IiLCJvdXRNaW1lVHlwZSIsImNvbXBpbGVyT3B0aW9ucyIsImlubGluZVNvdXJjZU1hcCIsImlubGluZVNvdXJjZXMiLCJnZXRJbnB1dE1pbWVUeXBlcyIsIl9nZXRQYXJzZWRDb25maWdPcHRpb25zIiwidHNDb21waWxlciIsInBhcnNlZENvbmZpZyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJidWlsdGluT3B0cyIsImZvckVhY2giLCJrIiwicmVzdWx0cyIsImNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbiIsImVycm9ycyIsImxlbmd0aCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInR5cGVzY3JpcHRPcHRzIiwib3B0aW9ucyIsImNvbXBpbGVTeW5jIiwic291cmNlQ29kZSIsImZpbGVQYXRoIiwiaXNUc3giLCJtYXRjaCIsInRyYW5zcGlsZU9wdGlvbnMiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwiaG90TW9kdWxlUmVsb2FkIiwiYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbiIsImdldEV4cG9ydHNGb3JGaWxlIiwib3V0cHV0IiwidHJhbnNwaWxlTW9kdWxlIiwic291cmNlTWFwcyIsInNvdXJjZU1hcFRleHQiLCJjb3ZlcmFnZSIsIm91dHB1dFRleHQiLCJJbnN0cnVtZW50ZXIiLCJpbnN0cnVtZW50U3luYyIsImRpYWdub3N0aWNzIiwiYmFiZWxPcHRzIiwiYmFiZWwiLCJCYWJlbENvbXBpbGVyIiwiZGVmYXVsdCIsInRzT3V0cHV0UGF0aCIsInJlcGxhY2UiLCJiYWJlbE91dHB1dFBhdGgiLCJiYWJlbE91dHB1dCIsImNoYWluIiwibG9hZFN5bmMiLCJjb250ZW50IiwiY29kZSIsInNvdXJjZW1hcHMiLCJwYXJzZSIsImZpbmFsU291cmNlTWFwcyIsImFwcGx5Iiwib3V0cHV0Q29kZSIsInRvVXJsIiwibWltZVR5cGUiLCJleHBvcnRzIiwicmVnaXN0cmF0aW9ucyIsIm1hcCIsIngiLCJpZCIsIm5hbWUiLCJ0bXBsIiwic291cmNlRmlsZSIsImNyZWF0ZVNvdXJjZUZpbGUiLCJTY3JpcHRUYXJnZXQiLCJFUzYiLCJyZXQiLCJ2aXNpdCIsIm5vZGUiLCJpc05vZGVFeHBvcnRlZCIsImtpbmQiLCJTeW50YXhLaW5kIiwiQ2xhc3NEZWNsYXJhdGlvbiIsIkZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwdXNoIiwidGV4dCIsImZvckVhY2hDaGlsZCIsImZsYWdzIiwiTm9kZUZsYWdzIiwiRXhwb3J0IiwicGFyZW50IiwiU291cmNlRmlsZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGlCQUFpQixDQUFDLGlCQUFELEVBQW9CLFVBQXBCLENBQXZCO0FBQ0EsTUFBTUMsSUFBSUMsUUFBUSxPQUFSLEVBQWlCLHNDQUFqQixDQUFWOztBQUVBLElBQUlDLEtBQUssSUFBVDtBQUNBLElBQUlDLFdBQVcsSUFBZjtBQUNBLElBQUlDLFVBQVUsSUFBZDs7QUFFQSxNQUFNQyxjQUFjLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsRUFBZ0MsT0FBaEMsQ0FBcEI7O0FBRWUsTUFBTUMsa0JBQU4sMENBQW9EO0FBQ2pFQyxnQkFBYztBQUNaOztBQUVBLFNBQUtDLFdBQUwsR0FBbUIsd0JBQW5CO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QjtBQUNyQkMsdUJBQWlCLElBREk7QUFFckJDLHFCQUFlO0FBRk0sS0FBdkI7QUFJRDs7QUFFRCxTQUFPQyxpQkFBUCxHQUEyQjtBQUN6QixXQUFPYixjQUFQO0FBQ0Q7O0FBRURjLDBCQUF3QkMsVUFBeEIsRUFBb0M7QUFDbEMsUUFBSUMsZUFBZSxLQUFL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S0FBcUJuRixHQUFHb0YsVUFBSCxDQUFjVSxVQUF0RztBQUNEOztBQUVEQyx1QkFBcUI7QUFDbkIsV0FBT2hHLFFBQVEseUJBQVIsRUFBbUNpRyxPQUExQztBQUNEO0FBM0pnRTtrQkFBOUM1RixrQiIsImZpbGUiOiJ0eXBlc2NyaXB0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTaW1wbGVDb21waWxlckJhc2V9IGZyb20gJy4uL2NvbXBpbGVyLWJhc2UnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQganNFc2NhcGUgZnJvbSAnanMtc3RyaW5nLWVzY2FwZSc7XG5cbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L3R5cGVzY3JpcHQnLCAndGV4dC90c3gnXTtcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnR5cGVzY3JpcHQtY29tcGlsZXInKTtcblxubGV0IHRzID0gbnVsbDtcbmxldCBpc3RhbmJ1bCA9IG51bGw7XG5sZXQgc29yY2VyeSA9IG51bGw7XG5cbmNvbnN0IGJ1aWx0aW5LZXlzID0gWydob3RNb2R1bGVSZWxvYWQnLCAnY292ZXJhZ2UnLCAnYmFiZWwnXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdENvbXBpbGVyIGV4dGVuZHMgU2ltcGxlQ29tcGlsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3V0TWltZVR5cGUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XG4gICAgdGhpcy5jb21waWxlck9wdGlvbnMgPSB7XG4gICAgICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXG4gICAgICBpbmxpbmVTb3VyY2VzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnB1dE1pbWVUeXBlcygpIHtcbiAgICByZXR1cm4gaW5wdXRNaW1lVHlwZXM7XG4gIH1cblxuICBfZ2V0UGFyc2VkQ29uZmlnT3B0aW9ucyh0c0NvbXBpbGVyKSB7XG4gICAgbGV0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnO1xuXG4gICAgaWYgKCFwYXJzZWRDb25maWcpIHtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMpO1xuICAgICAgbGV0IGJ1aWx0aW5PcHRzID0ge307XG4gICAgICBidWlsdGluS2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgIGlmIChrIGluIHRoaXMuY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdHNba107XG4gICAgICAgICAgYnVpbHRpbk9wdHNba10gPSB0aGlzLmNvbXBpbGVyT3B0aW9uc1trXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0c0NvbXBpbGVyLmNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbihvcHRzKTtcblxuICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzICYmIHJlc3VsdHMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzdWx0cy5lcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcgPSB7IHR5cGVzY3JpcHRPcHRzOiByZXN1bHRzLm9wdGlvbnMsIGJ1aWx0aW5PcHRzIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcbiAgfVxuXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XG4gICAgdHMgPSB0cyB8fCByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHMpO1xuXG4gICAgY29uc3QgaXNUc3ggPSBmaWxlUGF0aC5tYXRjaCgvXFwudHN4JC9pKTtcbiAgICBjb25zdCB0cmFuc3BpbGVPcHRpb25zID0ge1xuICAgICAgY29tcGlsZXJPcHRpb25zOiBvcHRpb25zLnR5cGVzY3JpcHRPcHRzLFxuICAgICAgZmlsZU5hbWU6IGZpbGVQYXRoLm1hdGNoKC9cXC4odHN8dHN4KSQvaSkgPyBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGlzVHN4ICYmIG9wdGlvbnMuYnVpbHRpbk9wdHMuaG90TW9kdWxlUmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc291cmNlQ29kZSA9IHRoaXMuYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlUGF0aCwgdGhpcy5nZXRFeHBvcnRzRm9yRmlsZShzb3VyY2VDb2RlLCBmaWxlUGF0aCkpO1xuICAgIH1cblxuICAgIGxldCBvdXRwdXQgPSB0cy50cmFuc3BpbGVNb2R1bGUoc291cmNlQ29kZSwgdHJhbnNwaWxlT3B0aW9ucyk7XG4gICAgbGV0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5idWlsdGluT3B0cy5jb3ZlcmFnZSkge1xuICAgICAgc291cmNlTWFwcyA9IG51bGw7XG4gICAgICBpc3RhbmJ1bCA9IGlzdGFuYnVsIHx8IHJlcXVpcmUoJ2lzdGFuYnVsJyk7XG5cbiAgICAgIHNvdXJjZU1hcHMgPSBudWxsO1xuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQub3V0cHV0VGV4dCwgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIGQoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmRpYWdub3N0aWNzKSk7XG5cbiAgICBjb25zdCBiYWJlbE9wdHMgPSB0aGlzLnBhcnNlZENvbmZpZy5idWlsdGluT3B0cy5iYWJlbDtcbiAgICBpZiAoYmFiZWxPcHRzKSB7XG4gICAgICBpZiAoIXRoaXMuYmFiZWwpIHtcbiAgICAgICAgY29uc3QgQmFiZWxDb21waWxlciA9IHJlcXVpcmUoXCIuL2JhYmVsXCIpLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuYmFiZWwgPSBuZXcgQmFiZWxDb21waWxlcigpO1xuICAgICAgICB0aGlzLmJhYmVsLmNvbXBpbGVyT3B0aW9ucyA9IGJhYmVsT3B0cztcbiAgICAgIH1cblxuICAgICAgc29yY2VyeSA9IHNvcmNlcnkgfHwgcmVxdWlyZSgnc29yY2VyeScpO1xuXG4gICAgICBsZXQgdHNPdXRwdXRQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvLnRzeD8kL2ksIFwiLmpzXCIpO1xuICAgICAgbGV0IGJhYmVsT3V0cHV0UGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoLy50c3g/JC9pLCBcIi5iYWJlbC5qc1wiKTtcblxuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSBvdXRwdXQub3V0cHV0VGV4dC5yZXBsYWNlKC9cXC9cXC8jIHNvdXJjZU1hcC4qL2csIFwiXCIpO1xuXG4gICAgICBsZXQgYmFiZWxPdXRwdXQgPSB0aGlzLmJhYmVsLmNvbXBpbGVTeW5jKG91dHB1dC5vdXRwdXRUZXh0LCB0c091dHB1dFBhdGgpO1xuICAgICAgbGV0IGNoYWluID0gc29yY2VyeS5sb2FkU3luYyhiYWJlbE91dHB1dFBhdGgsIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgIFtmaWxlUGF0aF06IHNvdXJjZUNvZGUsXG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgICAgIFtiYWJlbE91dHB1dFBhdGhdOiBiYWJlbE91dHB1dC5jb2RlLFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VtYXBzOiB7XG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IEpTT04ucGFyc2Uoc291cmNlTWFwcyksXG4gICAgICAgICAgW2JhYmVsT3V0cHV0UGF0aF06IEpTT04ucGFyc2UoYmFiZWxPdXRwdXQuc291cmNlTWFwcyksXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IGZpbmFsU291cmNlTWFwcyA9IGNoYWluLmFwcGx5KCk7XG4gICAgICBsZXQgb3V0cHV0Q29kZSA9IGJhYmVsT3V0cHV0LmNvZGUgKyBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgZmluYWxTb3VyY2VNYXBzLnRvVXJsKCk7XG5cbiAgICAgIC8vIHRoZSBvbmx5IHdheSB0byBtYWtlIHNvdXJjZU1hcHMgdXNhYmxlIHNlZW1zIHRvIGJlIHRvIGhhdmVcbiAgICAgIC8vIHRoZW0gaW5saW5lZCByaWdodCBub3csIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24tY29tcGlsZS9pc3N1ZXMvMTcyI2lzc3VlY29tbWVudC0yNzcxNDYxMTJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG91dHB1dENvZGUsXG4gICAgICAgIG1pbWVUeXBlOiBiYWJlbE91dHB1dC5taW1lVHlwZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgbWltZVR5cGU6IHRoaXMub3V0TWltZVR5cGUsXG4gICAgICBzb3VyY2VNYXBzXG4gICAgfTtcbiAgfVxuXG4gIGFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZU5hbWUsIGV4cG9ydHMpIHtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPCAxKSByZXR1cm4gc291cmNlQ29kZTtcblxuICAgIGxldCByZWdpc3RyYXRpb25zID0gZXhwb3J0cy5tYXAoeCA9PiB7XG4gICAgICBsZXQgaWQgPSBgJHt4fWAgPT0gJ2RlZmF1bHQnID8gJyh0eXBlb2YgX2RlZmF1bHQgIT09IFxcJ3VuZGVmaW5lZFxcJyA/IF9kZWZhdWx0IDogZXhwb3J0cy5kZWZhdWx0KScgOiBgJHt4fWA7XG4gICAgICBsZXQgbmFtZSA9IGBcIiR7eH1cImA7XG4gICAgICByZXR1cm4gYF9fUkVBQ1RfSE9UX0xPQURFUl9fLnJlZ2lzdGVyKCR7aWR9LCAke25hbWV9LCBfX0ZJTEVOQU1FX18pO1xcbmA7XG4gICAgfSk7XG5cbiAgICBsZXQgdG1wbCA9IGBcbiR7c291cmNlQ29kZX1cblxuaWYgKHR5cGVvZiBfX1JFQUNUX0hPVF9MT0FERVJfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgX19GSUxFTkFNRV9fID0gXCIke2pzRXNjYXBlKGZpbGVOYW1lKX1cIjtcbiAgJHtyZWdpc3RyYXRpb25zfVxufWA7XG5cbiAgICByZXR1cm4gdG1wbDtcbiAgfVxuXG4gIGdldEV4cG9ydHNGb3JGaWxlKHNvdXJjZUNvZGUsIGZpbGVOYW1lKSB7XG4gICAgbGV0IHNvdXJjZUZpbGUgPSB0cy5jcmVhdGVTb3VyY2VGaWxlKGZpbGVOYW1lLCBzb3VyY2VDb2RlLCB0cy5TY3JpcHRUYXJnZXQuRVM2KTtcbiAgICBsZXQgcmV0ID0gW107XG5cbiAgICAvLyBXYWxrIHRoZSB0cmVlIHRvIHNlYXJjaCBmb3IgY2xhc3Nlc1xuICAgIGxldCB2aXNpdCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNOb2RlRXhwb3J0ZWQobm9kZSkpIHJldHVybjtcblxuICAgICAgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uIHx8IG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldC5wdXNoKG5vZGUubmFtZS50ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHMuZm9yRWFjaENoaWxkKHNvdXJjZUZpbGUsIHZpc2l0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpc05vZGVFeHBvcnRlZChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmZsYWdzICYgdHMuTm9kZUZsYWdzLkV4cG9ydCkgIT09IDAgfHwgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuU291cmNlRmlsZSk7XG4gIH1cblxuICBnZXRDb21waWxlclZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3R5cGVzY3JpcHQvcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiAgfVxufVxuIl19